# 2048 AI求解器

## 简介

2048 AI求解器是一个使用人工智能技术自动玩2048游戏的项目。该项目的核心是一个高效的启发式算法，它可以评估棋盘上的每一步走法，并选择最优策略来获得最高分。

## 主要功能

- **自动游戏玩法**：AI可以完全自动地进行游戏，无需人工干预。
- **策略决策**：采用启发式算法评估棋盘状态，选择最有可能导致胜利的移动。
- **高分追求**：目标是最大化游戏得分，通过合并方格达到2048甚至4096。
- **跨平台支持**：代码兼容Windows、Linux和macOS等多种操作系统。

## 算法细节

### 棋盘表示

2048游戏的棋盘是一个4x4的方格，每个方格可以包含从0到2048的整数，或者是空的。在AI求解器中，我们使用一个64位的无符号整数（`uint64_t`）来表示整个棋盘。每个方格的值以4位二进制数存储在整数中，从而实现紧凑且高效的存储。

棋盘的位操作包括：

- **位移操作**：通过位移来访问棋盘的特定行或列。
- **掩码操作**：使用位掩码来设置、清除或检查特定的方格。
- **按位或操作**：用于合并棋盘状态与新生成的方格。



### 置换表

为了提高搜索效率，AI使用置换表（transposition table）来存储已经评估过的局面的评分。这个表是一个哈希表，其中键是棋盘状态的哈希值，值是该状态的评分和评估深度。当AI需要评估一个棋盘状态时，它首先检查置换表中是否已经有了该状态的评分，如果有，就直接使用，避免了重复计算。

### 移动执行

移动执行涉及到根据玩家的选择（上、下、左、右）更新棋盘状态。每个移动都对应一个函数，该函数负责执行以下步骤：

1. **收集**：将所选方向上的所有非零方格收集到一起。
2. **合并**：将相同的方格合并成一个新的方格，其值为两个方格值的和。
3. **填充**：在棋盘上空出的位置随机生成新的方格（2或4）。

### 深度优先搜索与启发式评分结合

AI使用深度优先搜索（DFS）来探索可能的移动序列，并使用启发式评分来评估每个移动序列的潜在价值。搜索的深度由启发式评分的置信度决定，评分越高的移动序列会被探索得更深。

搜索过程中，AI会维护一个当前最佳移动的记录，并在搜索结束时选择评分最高的移动。

## 启发式评分系统的深入分析

启发式评分系统是AI在2048游戏中做决策的核心机制。它需要综合考虑棋盘上的多种因素，并给出一个量化的评分，以此来判断哪个移动方向最优。

### 评分公式

启发式评分通常由以下几部分组成：

Score=w1​×Empty+w2​×Merges+w3​×Monotonicity+w4​×Distribution−w5​×Sum

其中：

- w1​,w2​,w3​,w4​,w5​ 是不同因素的权重系数。
- **Empty** 是棋盘上空格的数量。
- **Merges** 是指棋盘上可以合并的方格对的数量。
- **Monotonicity** 是衡量棋盘行或列中数字递增或递减的一致性。
- **Distribution** 是方格分布的均匀度。
- **Sum** 是棋盘上方格数值的总和，有时作为惩罚项，以避免过大的总和导致游戏结束。

### 权重选择

权重的选择对启发式评分的效果至关重要。过高或过低的权重都可能导致评分系统无法准确反映棋盘状态的真实价值。通常，权重的设定需要通过多次试验和调整来优化。

### 单调性评分

单调性评分是衡量棋盘上每一行或列中数字的顺序。理想情况下，每一行或列的数字应该是严格递增或递减的，这样的棋盘状态有利于未来的合并操作。

### 方格分布评分

方格分布评分考虑了棋盘上方格的分布均匀性。一个均匀分布的棋盘通常意味着更多的合并机会，因此会获得更高的评分。

### 实现细节

在C++代码中，启发式评分的实现涉及遍历棋盘的每一步，计算上述各个组成部分的值，并根据预设的权重来综合计算最终的评分。

### 搜索算法与评分结合

AI使用启发式评分来指导搜索算法，如深度优先搜索或蒙特卡洛树搜索。在搜索过程中，每个可能的移动都会被评估一个启发式评分，搜索算法根据评分来决定扩展哪些节点。

### 置换表的应用

在搜索过程中，AI会使用置换表来存储已经计算过的棋盘状态的评分。当遇到相同的棋盘状态时，可以直接从置换表中获取评分，从而避免重复计算，大大提高搜索效率。

# C++代码实现

### 主要文件和功能

- **2048.h/2048.cpp**：这些文件包含了游戏逻辑和AI算法的核心实现。
  
  - `board_t`：定义了棋盘的数据结构，使用`uint64_t`类型。
  - `init_tables()`：初始化游戏中用到的各种查找表，如移动转换表和启发式评分表。
  - `execute_move(int move, board_t board)`：执行给定方向的移动并返回新的棋盘状态。
  - `score_toplevel_move(board_t board, int move)`：评估给定移动的得分。
  - `find_best_move(board_t board)`：寻找并返回当前棋盘状态下的最佳移动。

- **config.h**：包含了编译时配置，确保代码的跨平台兼容性，定义了项目相关的宏和配置选项。

- **platdefs.h**：包含了平台相关的宏定义和函数实现，如随机数生成器`unif_random`和时间获取函数`gettimeofday`的跨平台实现。

### 关键数据结构

- `board_t`：使用`uint64_t`来表示整个棋盘，每个方格的值以4位存储。

- `struct trans_table_entry_t`：用于置换表中的条目，存储了评分和评分时的深度。

### 核心算法实现

- **随机数生成器**：根据不同平台支持的随机数生成函数，实现了跨平台的随机数生成器`unif_random`。

- **移动转换表**：使用预先计算好的表格来转换棋盘状态，而不是在每次移动时重新计算。

- **启发式评分**：根据棋盘上的分布和潜在的合并机会，为棋盘状态分配一个分数。

- **搜索算法**：实现了一个基于启发式评分的搜索算法，用于评估每一步移动的结果。

### 性能优化

- **内联函数**：对于频繁调用的小函数（如位操作相关的函数），使用内联函数来减少函数调用的开销。

- **位操作**：使用位操作来处理棋盘状态，这些操作比传统的算术操作更快。

- **查找表**：使用查找表来加速移动转换和评分过程，避免了重复计算。

### 测试和验证

- **打印函数**：实现了`print_board`函数来打印当前棋盘状态，便于调试。

- **单元测试**：可以编写单元测试来验证各个函数的正确性，如移动转换和评分函数。

- **集成测试**：通过运行AI并观察其玩游戏的过程来进行集成测试。

### 编译和运行

- **编译**：使用适合您平台的编译器（如gcc、clang或MSVC）编译代码。

- **运行**：编译后，可以直接运行生成的可执行文件来启动AI并玩游戏。

### 跨平台支持

- **宏定义**：通过宏定义来处理不同操作系统的兼容性问题。

- **函数封装**：对于特定平台特有的函数，如时间函数和随机数生成函数，进行了封装，以确保代码的可移植性。

### 测试和验证

虽然代码本身可能不包含自动化测试，但设计时考虑了测试的便利性，允许开发者通过简单的接口与AI交互，验证算法的有效性。

## 贡献

欢迎对项目做出贡献。如果您有新功能的想法或发现了错误，请提出问题或提交拉取请求。
